# Ключевая идея
Часто работая с БД, люди сталкиваются с проблемой дубликатов, непонятно откуда пришедших данных, а также отсутствие каких-либо полей в, казалось бы, одинаковых записях. 
![image](https://github.com/user-attachments/assets/4c8579a8-c6ca-4ebc-b7f8-e45d60a1f41f)

Наша команда предлагает элегантное решение, чтобы раз и навсегда решить эту проблему. Ключевые части - это рейтинг источника и мета данные для каждой строки в таблице.

## Решение
Вместо того, чтобы хранить каждую реплику записи, мы предлагаем предать значение каждой отдельной колонке.

Ведь нам очень важно: 
1. Не потеярть данные
2. Знать откуда они могли придти
3. Знать когда они пришли
4. Удобная интеграция с уже существующим
5. Скорость работы и масштабируемость
7. Занимаемая память
8. Очевидная логика работы с этим

Мы смогли объеденить эти качества в этом подходе. На схеме вы можете наблюдать алгоритм насыщения и замещения каждой отдельной ячейки. 
Здесь предлагается использовать структуру данных очередь с приоритетом, совмщененную с хэш таблицей. Для того, чтобы концепция была 
рабочей, нам нужно только 1 уникальное поле. Как только мы его получили, то при получении новых данных мы создаём историческую цепочку
изменения каждой ячейки в записе. А также вытесняем её на поверхность при насыщении за счет рейтинга источника.

![image](https://github.com/user-attachments/assets/feae4979-37e2-491f-b3a3-f4869f32051f)

Таким образом мы:
1. Всегда имеем единственную правдивую запись
2. Экономим память, исключая дубликаты
3. Помним кто и когда делал изменения
4. Алгоритмиески быстро обрабатываем данные

> P.S. Сейчас это сделано с помощью PostgreSQL, которая не имеет встроенной поддержки метаданных для ячеек. Текущая реализация использует JSONb. Однако, если сделать эту информацию бинарной с возможностью индексации, то алгоритм будет работать ещё быстрее, и вполне может стать стандартом в SQL или новым расширением для решения подобных задач. 
<img width="710" alt="image" src="https://github.com/user-attachments/assets/540ca085-aed6-4afd-8c2a-574bef2b6a8d">

Разумеется, что в жизни не всё можно предугадать, поэтому мы оставляем возможность удобного и красивого ручного решения конфликтов при слиянии данных. 

![image](https://github.com/user-attachments/assets/1f12b179-fadb-481a-990a-8836952aa514)

### 1. Сборка приложения бэкенда 
```shell
docker build -t t1-backend .
```

### 2. Запуск Docker compose
```shell
docker-compose up --build -d
```

### 3. Swagger доступен по адресу
```
http://localhost:3000/docs
```
### 4. Загрузка .csv с датасетом в Swagger
![image](https://github.com/user-attachments/assets/acf91990-05da-45d4-8b4c-a0bbd9dff0ea)
